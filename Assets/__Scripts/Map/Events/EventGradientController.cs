using UnityEngine;

public class EventGradientController : MonoBehaviour
{
    private static readonly int size = 256;
    [SerializeField] private SpriteRenderer spriteRenderer;

    private Texture2D currentTex;

    public void UpdateGradientData(MapEvent.ChromaGradient gradient)
    {
        if (currentTex != null) Destroy(currentTex);
        RegenerateTexture(gradient);
    }

    public void UpdateGradientData(MapEvent currentEvent, MapEvent nextEvent, EventAppearanceSO eaSO, bool boost)
    {
        if (currentTex != null) Destroy(currentTex);
        
        // Regenerate Texture
        Color startColor, endColor;
        if (currentEvent.Value == MapEvent.LightValueOff)
        {
            startColor = new Color(0,0,0,0);
        }
        else if (MapEvent.IsBlueEventFromValue(currentEvent.Value))
        {
            startColor = boost ? eaSO.BlueBoostColor : eaSO.BlueColor;
            startColor.a = currentEvent.FloatValue;
        }
        else
        {
            startColor = boost ? eaSO.RedBoostColor : eaSO.RedColor;
            startColor.a = currentEvent.FloatValue;
        }

        if (MapEvent.IsBlueEventFromValue(nextEvent.Value))
        {
            endColor = boost ? eaSO.BlueBoostColor : eaSO.BlueColor;
            endColor.a = nextEvent.FloatValue;
        }
        else
        {
            endColor = boost ? eaSO.RedBoostColor : eaSO.RedColor;
            endColor.a = nextEvent.FloatValue;
        }
        
        var texture = Create(new[] { startColor, endColor });
        currentTex = texture;

        var sprite = Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), Vector2.one / 2f, size);
        sprite.name = "Autogenerated Gradient";
        spriteRenderer.sprite = sprite;

        UpdateDuration(nextEvent.Time - currentEvent.Time);
        currentEvent.nextEvent = nextEvent;
    }

    public void UpdateDuration(float duration) => transform.localScale =
        new Vector3(duration * EditorScaleController.EditorScale * (-4f / 3), size, 1);

    public void SetVisible(bool visible) => spriteRenderer.enabled = visible;

    /// <summary>
    ///     Taken and modified from <see cref="ColorSliderImage.RegenerateTexture" />
    /// </summary>
    private void RegenerateTexture(MapEvent.ChromaGradient gradient)
    {
        var startColor = gradient.StartColor;
        var endColor = gradient.EndColor;

        var texture = Create(new[] { startColor, endColor }, gradient);
        currentTex = texture;

        var sprite = Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), Vector2.one / 2f, size);
        sprite.name = "Autogenerated Gradient";
        spriteRenderer.sprite = sprite;
    }

    private static Texture2D Create(Color[] colors, MapEvent.ChromaGradient chromaGradient = null,
        TextureWrapMode textureWrapMode = TextureWrapMode.Clamp, FilterMode filterMode = FilterMode.Point,
        bool isLinear = false, bool hasMipMap = false)
    {
        if (colors == null || colors.Length == 0)
        {
            Debug.LogError("No colors assigned");
            return null;
        }

        var length = colors.Length;
        if (colors.Length > 8)
        {
            Debug.LogWarning("Too many colors! maximum is 8, assigned: " + colors.Length);
            length = 8;
        }

        // build gradient from colors
        var colorKeys = new GradientColorKey[length];
        var alphaKeys = new GradientAlphaKey[length];

        var steps = length - 1f;
        for (var i = 0; i < length; i++)
        {
            var step = i / steps;
            colorKeys[i].color = colors[i];
            colorKeys[i].time = step;
            alphaKeys[i].alpha = colors[i].a;
            alphaKeys[i].time = step;
        }

        // create gradient
        var gradient = new Gradient();
        gradient.SetKeys(colorKeys, alphaKeys);

        // create texture
        var outputTex = new Texture2D(256, 1, TextureFormat.ARGB32, hasMipMap, isLinear)
        {
            wrapMode = textureWrapMode,
            filterMode = filterMode
        };

        System.Func<float, float> easing;
        if (chromaGradient == null)
            easing = Easing.ByName["easeLinear"];
        else
            easing = Easing.ByName[chromaGradient.EasingType];

        // draw texture
        for (var i = 0; i < size; i++) outputTex.SetPixel(i, 0, gradient.Evaluate(easing((float)i / size)));
        outputTex.Apply(false);

        return outputTex;
    } // BuildGradientTexture
}
